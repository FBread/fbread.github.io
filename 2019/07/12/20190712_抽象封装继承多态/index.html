<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>抽象封装继承多态 | 面包土豆西红柿</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="抽象,封装,继承,重写,堆栈,数据存储,作用域,object">
<meta property="og:type" content="article">
<meta property="og:title" content="抽象封装继承多态">
<meta property="og:url" content="https://fbread.github.io/2019/07/12/20190712_%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/index.html">
<meta property="og:site_name" content="面包土豆西红柿">
<meta property="og:description" content="抽象,封装,继承,重写,堆栈,数据存储,作用域,object">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://fbread.github.io/assets/img/20190715-1.png">
<meta property="article:published_time" content="2019-07-11T23:29:41.000Z">
<meta property="article:modified_time" content="2024-05-28T08:30:19.264Z">
<meta property="article:author" content="Ziyi Jiang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fbread.github.io/assets/img/20190715-1.png">
  
    <link rel="alternate" href="/atom.xml" title="面包土豆西红柿" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">面包土豆西红柿</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fbread.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-20190712_抽象封装继承多态" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/07/12/20190712_%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/" class="article-date">
  <time class="dt-published" datetime="2019-07-11T23:29:41.000Z" itemprop="datePublished">2019-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      抽象封装继承多态
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>面向对象三大特征或四大特征都可以.</p>
<h4 id="1-抽象"><a href="#1-抽象" class="headerlink" title="1.抽象"></a>1.抽象</h4><p>设计类的过程称为抽象<br>类是对象的抽象,类是具有相同或相似的特征和行为的对象的抽象</p>
<h4 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h4><p>使用各种合适的访问限定符修饰属性方法和类<br>规范:类都是public的,方法都是public的,属性都是private的<br>属性的访问:构造方法&#x2F;访问器方法.</p>
<ul>
<li><p>A:封装概述</p>
<ul>
<li><p>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</p>
</li>
<li><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。</p>
</li>
</ul>
</li>
<li><p>B:封装好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高了代码的复用性</li>
<li>提高安全性。</li>
</ul>
</li>
<li><p>C:封装原则</p>
<ul>
<li>将不需要对外提供的内容都隐藏起来。</li>
<li>把属性隐藏，提供公共方法对其访问。</li>
</ul>
</li>
</ul>
<h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h4><p>类和类之间的关系,被继承的类称为父类,继承父类的类称为子类.<br>父类:超类 基类 元类 祖先类 上层类 &lt;—– (一个意思)<br>子类:后代类 继承类 &lt;—– (一个意思)<br>对于父类所有的东西(属性&#x2F;方法),子类都可以拥有.<br>本质:<br>提高类和类之间的代码的复用性.</p>
<h4 id="4-继承的语法"><a href="#4-继承的语法" class="headerlink" title="4.继承的语法"></a>4.继承的语法</h4><p>父类语法:</p>
<pre><code>public class A&#123;
&#125;
</code></pre>
<p>子类语法:</p>
<pre><code>public class B extends A&#123;
&#125;
</code></pre>
<p>注意:<br>1)extends表示继承,s不能省略<br>2)java在类层次上只支持单继承—-一个类只能有一个直接父类()<br>3)父类的属性和方法,子类都拥有,但是不一定能用<br>–父类的私有属性,子类不能直接访问<br>4)构造方法不能继承<br>5)如果子类自定义了和父类重名的属性,会直接覆盖;<br>重名的方法可能覆盖,可能重载<br>6)一个类可以有很多子类<br>7)子类之间的关系是兄弟关系,互不干涉也无法互相继承<br>8)对于父类的私有属性,子类拥有但是不能直接访问.可以使用继承下来的父类中公有的访问器方法访问.</p>
<h4 id="5-方法的重写-override"><a href="#5-方法的重写-override" class="headerlink" title="5.方法的重写(override)"></a>5.方法的重写(override)</h4><p>子类方法对于父类方法的覆盖—&gt;子类方法对于父类方法的<strong>重新实现</strong>—&gt;重写<br>和重载的区别:<br>1)重写只能发生在两个类之间,重载可以在一个类内部<br>2)重写是对父类方法的重新实现,父类方法在子类对象中无法调用,重载是对方法的延伸实现,使得方法更具有多样性<br>3)重写的方法和原方法的方法名,返回值类型以及参数列表完全一致.重载要求方法名一致,参数列表不一致</p>
<p>注意:<br>1)子类不重写父类方法,子类对象直接使用父类的方法<br>2)子类重写父类方法,子类对象使用子类重写之后的方法<br>3)重写方法的过程中,方法名和参数列表不允许修改,访问限定符的范围<strong>允许放大</strong><br>&#x2F;&#x2F;只有返回值类型不同的两个方法,会报错,系统不知道指的是哪个.</p>
<p>@Override<br>方法重写的标志,一般对于重写的方法需要在方法上添加<br>@Override称为注释(注解),如果不添加也可以,但是不规范</p>
<p>重写的快捷键: alt+s —&gt;Override &#x2F; Implements<br>methods—&gt;选择要重写的方法,选择override</p>
<h4 id="6-在子类中调用父类的方法"><a href="#6-在子类中调用父类的方法" class="headerlink" title="6.在子类中调用父类的方法"></a>6.在子类中调用父类的方法</h4><p>父类中的方法是普通的方法,该方法的调用需要使用父类的对象进行调用.<br>我们可以使用super来调用父类的方法.<br>super类似于this(this表示当前对象的引用),super表示当前对象所继承的父类对象的引用<br>super负责在子类重写父类方法的时候调用父类的方法.(只有在重写的时候有最后的机会调用父类的这个方法)<br>super.方法();</p>
<h4 id="7-子类对象的构建过程"><a href="#7-子类对象的构建过程" class="headerlink" title="7.子类对象的构建过程"></a>7.子类对象的构建过程</h4><p>第一步,先执行子类的构造方法<br>第二步,在子类构造方法的第一行跳转到父类的构造方法开始执行<br>隐式调用super();—代表父类的构造方法<br>(this();代表当前类的构造方法)<br>注意:super();只能写在子类构造方法的第一行,也可以不写,但是默认会生成(看不到)<br>&#x2F;&#x2F;子类继承了父类的成员变量,但是不能继承父类的构造函数,可以使用super()来解决成员变量赋值的重复代码.<br>第三步,父类的构造方法执行完毕后,回到子类的构造方法继续执行<br>第四步,子类的构造方法完成之后,子类的对象构建完毕</p>
<p>**继承的本质:<br>构建子类对象的过程中完整的执行了父类的构造方法,意味着在此过程中构建了一个父类的对象,在执行子类构造的过程中,父类的对象被拆分,父类的属性和方法拼接成子类的对象.**<br>(…联想到了很可怕的画面&#x3D;_&#x3D;)</p>
<h4 id="8-Object"><a href="#8-Object" class="headerlink" title="8.Object"></a>8.Object</h4><p>是Java设计者提供的一个类,它是除了自身之外其他所有类的父类.<br>如果一个类extends指定了父类,Object是当前类的<strong>间接父类</strong>;<br>如果一个类没有指定父类,Object是当前类的<strong>直接父类</strong>;(类似于爷爷辈的)</p>
<h4 id="9-栈Stack"><a href="#9-栈Stack" class="headerlink" title="9.栈Stack"></a>9.栈Stack</h4><p>又被称为”堆栈”,是一个只有一个出入口的容器.<br>存储的数据从该口进出,先进去的数据后出来,后进去的数据先出来,称为”FILO”&#x2F;“FOlI”(first<br>input last output)(就是先进后出&#x2F;先出后进)结构.<br>一个出口一个入口,方便管理</p>
<h4 id="10-堆Heap"><a href="#10-堆Heap" class="headerlink" title="10.堆Heap"></a>10.堆Heap</h4><p>是一个没有管理者的容量很大的容器(类似于垃圾场&#x2F;垃圾房)<br>里面存放的东西杂乱无章,可以知道该容器什么时候会满.</p>
<h4 id="11-堆和堆栈"><a href="#11-堆和堆栈" class="headerlink" title="11.堆和堆栈"></a>11.堆和堆栈</h4><p>Java程序在运行的时候在内存中,<br>Java程序不能直接修改内存,java运行于虚拟机上,虚拟机影响内存.<br>Java程序在运行的时候依靠jvm在系统内存中划出一片很大的区域600M~1000M.该内存被当前程序中所有的线程共享,称为Java的堆内存<br>在方法被<strong>调用</strong>的时候,此时针对每一个方法,jvm生成一个堆栈(栈),又被称为方法栈.在方法调用结束的时候(方法调用结束的标志是return做出返回值&#x2F;或者运行到方法体的最后一行),方法栈被销毁.方法栈称为java的栈内存.<br><img src="/assets/img/20190715-1.png" alt="堆栈结构" title="堆栈结构"></p>
<h4 id="12-数据的存储"><a href="#12-数据的存储" class="headerlink" title="12.数据的存储"></a>12.数据的存储</h4><p>数据类型的分类:<br>基本数据类型 byte short int long float double Boolean char<br>引用数据类型<br>存放该数据的变量是否允许.操作:允许的是引用数据类型.</p>
<p>基本数据类型:<br>存放在栈内存中,针对”int a &#x3D; 12;”而言,”int<br>a”称为引用,”12”称为值,基本数据类型的引用和值都在栈里面.<br>引用数据类型:<br>“int[] arr&#x3D;{1,2,3}”引用部分”int[]<br>arr”存放在栈里面,”{1,2,3}”数据部分存放在堆里面.我们把堆内存中真实的数据部分所占据的空间在jvm里面的编号存放在”int[]<br>arr”里面,该编号是一个十进制的数字,我们把这个数字称为hashcode(哈希值).<br>注意:Java中没有地址的概念,只有jvm编号—&gt;hashcode</p>
<h4 id="13-两种数据类型修改值的情况"><a href="#13-两种数据类型修改值的情况" class="headerlink" title="13.两种数据类型修改值的情况"></a>13.两种数据类型修改值的情况</h4><p>场景:<br>A方法中定义数据,调用B方法把A方法中定义的数据作为该方法的参数对该数据进行修改.<br>现象:<br>基本数据类型:B方法中值的修改无效.<br>引用数据类型:B方法中值的修改有效.</p>
<p>结论:<br>对于基本数据类型,作为参数的时候传递的并不是数据本身,而是数据的值,称为值传递.<br>对于引用数据类型,作为参数的时候传递的是数据本身,修改是有效的,称为引用传递.&#x2F;&#x2F;传得这是地址么<br>–传递的都是值,只不过引用数据类型存储的是堆中的一个位置????<br>上述的结论可以辅助记忆,但不是很准确.</p>
<pre><code>//基本数据类型
public class Test01 &#123;
    public static void main(String[] args) &#123;    
        int number = 10;
        add(number);
        System.out.println(number);//10
    &#125;
    public static void add(int number) &#123;
        number = 12;
    &#125;
&#125;
//引用数据类型
public class Test02 &#123;
    public static void main(String[] args) &#123;    
    int arr[] = &#123;10&#125;;
    add(arr);
    System.out.println(arr[0]);//12
&#125;
    public static void add(int[] arr) &#123;
        arr[0] = 12;
    &#125;
&#125;
</code></pre>
<h4 id="14-变量的作用域"><a href="#14-变量的作用域" class="headerlink" title="14. 变量的作用域"></a>14. 变量的作用域</h4><p>全局变量:<br>类的属性称为全局变量,该变量和所有的方法平级,因此可以被所有的方法共享,且无须作为方法的参数传入.<br>全局变量可以设置初始值,但是一般不设置.<br>局部变量:<br>方法内部定义的变量,以及方法参数列表中的参数称为方法的局部变量,专属于该方法,可以通过传参的方式传递给其他方法使用—&gt;值传递和引用传递.</p>
<p>如果在方法内部存在一个和全局变量重名的局部变量,此时全局变量会临时失效,在该方法内部使用的是局部变量的值.</p>
<pre><code>public class Test02 &#123;
    private static int number = 10;
    public static void main(String[] args) &#123;
        int number = 12;
        System.out.println(number);//12
        show();//10
    &#125;
    public static void show() &#123;
        System.out.println(number);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>成员变量和局部变量的区别:</p>
<ul>
<li><p>A:在类中的位置不同</p>
<ul>
<li>成员变量：在类中方法外</li>
<li>局部变量：在方法定义中或者方法声明上</li>
</ul>
</li>
<li><p>B:在内存中的位置不同</p>
<ul>
<li>成员变量：在堆内存(成员变量属于对象,对象进堆内存)</li>
<li>局部变量：在栈内存(局部变量属于方法,方法进栈内存)</li>
</ul>
</li>
<li><p>C:生命周期不同</p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li>
</ul>
</li>
<li><p>D:初始化值不同</p>
<ul>
<li>成员变量：有默认初始化值</li>
<li>局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</li>
<li>基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char</li>
<li>引用数据类型变量包括哪些:数组,类,接口,枚举</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="15-随机数Random"><a href="#15-随机数Random" class="headerlink" title="15.随机数Random"></a>15.随机数Random</h4><p>伪随机数,根据种子产生的数</p>
<pre><code>Random rd = new Random();    //种子是纳秒值
int num = rd.nextInt();//取值范围是int的范围
int num = rd.nextInt(10);
//.nextInt(n) 均匀分布int值介于[o,n);    ]

int num2 = rd.nextInt(end-start+1)+start;
//start-end范围内的随机数

Random rd2 = new Random(1000);//指定种子
int a = rd2.nextInt();//每次数都一样
</code></pre>
<p>用法很多</p>
<h4 id="辟谣言论"><a href="#辟谣言论" class="headerlink" title="辟谣言论"></a>辟谣言论</h4><p>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br>1)子类只能继承父类所有的非private的属性和方法 错<br><strong>父类的属性和方法,子类都拥有,但是不一定能用<br>–父类的私有属性,子类不能直接访问</strong><br>2)构建子类对象的时候,先执行父类的构造方法 错<br>3)</p>
<p>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fbread.github.io/2019/07/12/20190712_%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/" data-id="clwr7f1df000pt8gb6l778l7j" data-title="抽象封装继承多态" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/15/20190715_%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          抽象封装继承多态-2
        
      </div>
    </a>
  
  
    <a href="/2019/07/11/20190711_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面向对象-2</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Idea/" rel="tag">Idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Postgres/" rel="tag">Postgres</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quartz/" rel="tag">Quartz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thymeleaf/" rel="tag">Thymeleaf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cookie/" rel="tag">cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/session/" rel="tag">session</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Idea/" style="font-size: 10px;">Idea</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Postgres/" style="font-size: 10px;">Postgres</a> <a href="/tags/Quartz/" style="font-size: 10px;">Quartz</a> <a href="/tags/Thymeleaf/" style="font-size: 10px;">Thymeleaf</a> <a href="/tags/cookie/" style="font-size: 10px;">cookie</a> <a href="/tags/session/" style="font-size: 10px;">session</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/30/20240530-thymeleaf-1/">thymeleaf-1</a>
          </li>
        
          <li>
            <a href="/2024/05/29/20240529_Postgres%E5%AE%9E%E7%8E%B0on%20update%20current_timestamp/">Postgres实现on update current_timestamp</a>
          </li>
        
          <li>
            <a href="/2024/05/28/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/10/18/20191018_quartz/">Quartz</a>
          </li>
        
          <li>
            <a href="/2019/10/15/20191015_shiro/">Shiro</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Ziyi Jiang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>